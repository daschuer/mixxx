#=============================================================================
# CMakeDebHelper, Copyright (C) 2013 Sebastian Kienzl
# http://knzl.de/cmake-debhelper/
# Licensed under the GPL v2, see LICENSE
#=============================================================================

find_program( CPACK_DEBIAN_DEBHELPER dh_prep )
if( NOT CPACK_DEBIAN_DEBHELPER )
	message( NOTICE "debhelper not found, required for cpack -G DEB" )
endif()

execute_process(COMMAND whoami OUTPUT_VARIABLE _DH_USER)
string(STRIP "${_DH_USER}" _DH_USER)
if (NOT _DH_USER STREQUAL "root")
	message( FATAL_ERROR "_11111111 ${CPACK_DEBIAN_FAKEROOT} _${_DH_USER}_ ${CPACK_DEBIAN_DEBHELPER}" )
	# Some debhelpers need fakeroot, we use it for all of them
	find_program( CPACK_DEBIAN_FAKEROOT fakeroot )
	if( NOT CPACK_DEBIAN_FAKEROOT )
		message( NOTICE "fakeroot not found, required for cpack -G DEB" )
	endif()
endif()

IF((CPACK_DEBIAN_FAKEROOT OR _DH_USER STREQUAL "root") AND CPACK_DEBIAN_DEBHELPER)
	# configure() .in-files to the CURRENT_BINARY_DIR
	foreach( _F ${DH_INPUT} )
		# strip the .in part
		string( REGEX REPLACE ".in$" "" _F_WE ${_F} )
		configure_file( ${_F} ${_F_WE} @ONLY )
	endforeach()

	# compat and control is only needed for running the debhelpers,
	# CMake is going to make up the one that ends up in the deb.
	file( WRITE ${CMAKE_CURRENT_BINARY_DIR}/compat "9" )
	if( NOT CPACK_DEBIAN_PACKAGE_NAME )
		if( NOT CPACK_PACKAGE_NAME )
			string( TOLOWER "${CMAKE_PROJECT_NAME}" CPACK_DEBIAN_PACKAGE_NAME )
		else()
			string( TOLOWER "${CPACK_PACKAGE_NAME}" CPACK_DEBIAN_PACKAGE_NAME )
		endif()
	endif()
	file( WRITE ${CMAKE_CURRENT_BINARY_DIR}/control "Source: ${CPACK_DEBIAN_PACKAGE_NAME}\n\nPackage: ${CPACK_DEBIAN_PACKAGE_NAME}\nArchitecture: any\n" )

	# Compose a string with a semicolon-seperated list of debhelpers
	foreach( _DH ${DH_RUN} )
		set( _DH_RUN_SC_LIST "${_DH_RUN_SC_LIST} ${_DH} ;" )
	endforeach()


	if( CPACK_DEBIAN_FAKEROOT )
		set( _DH_RUN_COMMAND ${CPACK_DEBIAN_FAKEROOT} -- sh -c "${_DH_RUN_SC_LIST}" )
 	else()
		set( _DH_RUN_COMMAND sh -c "${_DH_RUN_SC_LIST}" )
	endif()

	# Making sure the debhelpers run each time we change one of ${DH_INPUT}
	add_custom_command(
		OUTPUT dhtimestamp

		# dh_prep is needed to clean up, dh_* aren't idempotent
		COMMAND ${CPACK_DEBIAN_FAKEROOT} dh_prep

		# I haven't found another way to run a list of commands here
		COMMAND ${_DH_RUN_COMMAND}

		# needed to create the files we'll use
		COMMAND ${CPACK_DEBIAN_FAKEROOT} dh_installdeb

		COMMAND touch ${CMAKE_CURRENT_BINARY_DIR}/dhtimestamp
		WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/..
		DEPENDS ${DH_INPUT}
		COMMENT "Running debhelpers"
		VERBATIM
	)

	add_custom_target( dhtarget ALL
		DEPENDS dhtimestamp
	)
endif()

# these files are generated by debhelpers from our templates
set( CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA "" )
foreach( _F ${DH_GENERATED_CONTROL_EXTRA} )
	set( CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA
			${CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA}
			${CMAKE_CURRENT_BINARY_DIR}/${CPACK_DEBIAN_PACKAGE_NAME}/DEBIAN/${_F}
			CACHE INTERNAL ""
	)
endforeach()

# This will copy the generated dhhelper-files to our to-be-cpacked-directory.
# CPACK_INSTALL_SCRIPT must be set to the value of CPACK_DEBIAN_INSTALL_SCRIPT in the file
# pointed to by CPACK_PROJECT_CONFIG_FILE.
set( CPACK_DEBIAN_INSTALL_SCRIPT ${CMAKE_CURRENT_LIST_DIR}/CMakeDebHelperInstall.cmake CACHE INTERNAL "" )
